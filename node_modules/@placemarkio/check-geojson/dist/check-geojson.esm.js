import { evaluate, parse } from '@humanwhocodes/momoa';

function makeIssue(message, node) {
  return {
    message,
    severity: 'error',
    from: node.loc.start.offset,
    to: node.loc.end.offset
  };
}
class HintError extends Error {
  constructor(issues) {
    super();
    this.issues = []; // restore prototype chain

    const actualProto = new.target.prototype;
    Object.setPrototypeOf(this, actualProto);
    this.issues = issues;
  }

  get message() {
    return JSON.stringify(this.issues, null, 2);
  }

}

const GEOJSON_FEATURE_TYPE = /*#__PURE__*/new Set(['Feature']);
const GEOJSON_GEOMETRY_TYPES = /*#__PURE__*/new Set(['Point', 'MultiPoint', 'Polygon', 'MultiPolygon', 'LineString', 'MultiLineString', 'GeometryCollection']);
const GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION = /*#__PURE__*/new Set(['Point', 'MultiPoint', 'Polygon', 'MultiPolygon', 'LineString', 'MultiLineString']);
const GEOJSON_TYPES = /*#__PURE__*/new Set([...GEOJSON_GEOMETRY_TYPES, 'Feature', 'FeatureCollection']);

function getType(issues, node, allowedTypes) {
  if (node.type !== 'Object') {
    throw new HintError([makeIssue('Expected an object, but found an incorrect type.', node)]);
  }

  const typeMember = node.members.find(member => {
    return member.name.value === 'type';
  });

  if (!typeMember) {
    issues.push(makeIssue('This GeoJSON object is missing its type member.', node));
    return {};
  }

  const value = typeMember.value;

  if (value.type !== 'String') {
    issues.push(makeIssue('The type member should have been a string.', node));
    return {};
  }

  if (!allowedTypes.has(value.value)) {
    issues.push(makeIssue('This type of GeoJSON object is not allowed here.', node));
    return {};
  }

  return {
    type: value.value,
    objectNode: node
  };
}

function getMemberValue(issues, node, name) {
  const member = node.members.find(member => {
    return member.name.value === name;
  });

  if (!member) {
    issues.push(makeIssue(`This GeoJSON object requires a ${name} member but it is missing.`, node));
    return null;
  }

  return member.value;
}

function getArray(issues, node) {
  if ((node == null ? void 0 : node.type) === 'Array') return node;

  if (node) {
    issues.push(makeIssue('This must be an array.', node));
  }

  return null;
}

function getObject(issues, node) {
  if ((node == null ? void 0 : node.type) === 'Object') return node;

  if (node) {
    issues.push(makeIssue('This must be an object.', node));
  }

  return null;
}

function getCoordinates(issues, node) {
  const coordinatesMember = getMemberValue(issues, node, 'coordinates');
  if (!coordinatesMember) return null;
  return getArray(issues, coordinatesMember);
}

function arrayIsNumbers(issues, elements, name) {
  for (let element of elements) {
    if (element.type !== 'Number') {
      issues.push(makeIssue(`Each element in a ${name} must be a number.`, element));
      return;
    }
  }
}

function enforcePosition(issues, node) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;

  if (node.elements.length < 2 || node.elements.length > 3) {
    issues.push(makeIssue(`A position should have 2 or 3 elements - found ${node.elements.length}.`, node));
  }

  arrayIsNumbers(issues, node.elements, 'position');
}

function checkDuplicateKeys(issues, parent) {
  let keys = new Set();

  for (let node of parent.members) {
    const {
      name: {
        value
      }
    } = node;

    if (keys.has(value)) {
      issues.push(makeIssue('Duplicate properties are ambiguous in GeoJSON', node));
    }

    keys.add(value);
  }

  return parent;
}

function enforceSamePosition(issues, node) {
  const first = node.elements[0];
  const last = node.elements[node.elements.length - 1];
  const len = Math.max(first.elements.length, last.elements.length);

  for (let j = 0; j < len; j++) {
    var _first$elements$j, _last$elements$j;

    const firstValue = (_first$elements$j = first.elements[j]) == null ? void 0 : _first$elements$j.value;
    const secondValue = (_last$elements$j = last.elements[j]) == null ? void 0 : _last$elements$j.value;

    if (firstValue !== secondValue) {
      issues.push(makeIssue('First and last positions of a Polygon or MultiPolygon’s ring should be the same.', first), makeIssue('First and last positions of a Polygon or MultiPolygon’s ring should be the same.', last));
      return;
    }
  }
}

function getArray$1(issues, node) {
  if (node.type !== 'Array') {
    issues.push(makeIssue('Expected to find an array of positions here.', node));
    return null;
  }

  return node;
}

function enforcePositionArray(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    if (element.type !== 'Array') {
      issues.push(makeIssue('Expected to find a position here, found another type.', element));
      return;
    } else {
      enforcePosition(issues, element);
    }
  }

  switch (kind) {
    case 'LineString':
      {
        if (node.elements.length < 2) {
          issues.push(makeIssue('Expected to find two or more positions here.', node));
        }

        break;
      }

    case 'Polygon':
      if (node.elements.length < 4) {
        issues.push(makeIssue('Expected to find four or more positions here.', node));
      }

      enforceSamePosition(issues, node);
      break;
  }
}
function enforcePositionArray2(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    enforcePositionArray(issues, element, kind);
  }
}
function enforcePositionArray3(issues, node, kind) {
  // This error has already been caught. Allow a no-op for simplicity.
  if (node === null) return;
  node = getArray$1(issues, node);
  if (!node) return;

  for (let element of node.elements) {
    enforcePositionArray2(issues, element, kind);
  }
}

function enforceBbox(issues, node) {
  const member = node.members.find(member => {
    return member.name.value === 'bbox';
  }); // bboxes are optional

  if (member === undefined) return;
  const array = getArray(issues, member.value);
  if (!array) return;

  if (!(array.elements.length === 4 || array.elements.length === 6)) {
    issues.push(makeIssue('A bbox must have 4 or 6 positions', array));
  }

  arrayIsNumbers(issues, array.elements, 'bbox');
}

function forbidProperty(issues, member, propertiesFrom, name) {
  if (member.name.value === name) {
    issues.push(makeIssue(`${propertiesFrom} objects cannot contain a member named ${member.name.value}`, member.name));
  }
}

const FORBIDDEN_PROPERTIES = {
  Geometry: ['properties', 'geometry', 'features'],
  Feature: ['features'],
  FeatureCollection: ['properties', 'coordinates']
};
function forbidConfusingProperties(issues, node, propertiesFrom) {
  for (let member of node.members) {
    for (let property of FORBIDDEN_PROPERTIES[propertiesFrom]) {
      forbidProperty(issues, member, propertiesFrom, property);
    }
  }
}

const checkGeometryShared = (issues, node) => {
  enforceBbox(issues, node);
  forbidConfusingProperties(issues, node, 'Geometry');
};

const checkLineString = (issues, node) => {
  enforcePositionArray(issues, getCoordinates(issues, node), 'LineString');
  checkGeometryShared(issues, node);
};

const checkMultiLineString = (issues, node) => {
  enforcePositionArray2(issues, getCoordinates(issues, node), 'LineString');
  checkGeometryShared(issues, node);
};

const checkPolygon = (issues, node) => {
  enforcePositionArray2(issues, getCoordinates(issues, node), 'Polygon');
  checkGeometryShared(issues, node);
};

const checkMultiPolygon = (issues, node) => {
  enforcePositionArray3(issues, getCoordinates(issues, node), 'Polygon');
  checkGeometryShared(issues, node);
};

const checkPoint = (issues, node) => {
  enforcePosition(issues, getCoordinates(issues, node));
  checkGeometryShared(issues, node);
};

const checkMultiPoint = (issues, node) => {
  enforcePositionArray(issues, getCoordinates(issues, node));
  checkGeometryShared(issues, node);
};

const checkGeometryCollection = (issues, node) => {
  checkGeometryShared(issues, node);
  const geometriesMember = getArray(issues, getMemberValue(issues, node, 'geometries'));
  if (!geometriesMember) return;

  for (let element of geometriesMember.elements) {
    checkObject(issues, element, GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION);
  }
};

const checkFeature = (issues, node) => {
  forbidConfusingProperties(issues, node, 'Feature');
  const geometryMember = getMemberValue(issues, node, 'geometry');
  enforceBbox(issues, node);

  if ((geometryMember == null ? void 0 : geometryMember.type) !== 'Null') {
    const geometry = getObject(issues, geometryMember);
    if (geometry) checkObject(issues, geometry, GEOJSON_GEOMETRY_TYPES);
  }

  const idMember = node.members.find(member => {
    return member.name.value === 'id';
  });

  if (idMember && !(idMember.value.type === 'String' || idMember.value.type === 'Number')) {
    issues.push(makeIssue(`The Feature id must be a string or number.`, node));
  }

  const properties = getMemberValue(issues, node, 'properties');

  if (!properties) {
    issues.push(makeIssue(`The properties member is missing.`, node));
    return;
  }

  const {
    type
  } = properties;

  if (!(type === 'Object' || type === 'Null')) {
    issues.push(makeIssue(`The Feature properties member can be an object or null.`, node));
  }
};

const checkFeatureCollection = (issues, node) => {
  forbidConfusingProperties(issues, node, 'FeatureCollection');
  const featuresMember = getArray(issues, getMemberValue(issues, node, 'features'));
  if (!featuresMember) return;

  for (let feature of featuresMember.elements) {
    const obj = getObject(issues, feature);

    if (obj) {
      getType(issues, obj, GEOJSON_FEATURE_TYPE);
      checkFeature(issues, obj);
    }
  }
};

const CHECKERS = {
  LineString: checkLineString,
  MultiLineString: checkMultiLineString,
  Polygon: checkPolygon,
  MultiPolygon: checkMultiPolygon,
  Point: checkPoint,
  MultiPoint: checkMultiPoint,
  GeometryCollection: checkGeometryCollection,
  Feature: checkFeature,
  FeatureCollection: checkFeatureCollection
};

function checkObject(issues, node, typeSet = GEOJSON_TYPES) {
  const {
    type,
    objectNode
  } = getType(issues, node, typeSet);
  if (!(type && objectNode)) return;
  checkDuplicateKeys(issues, objectNode);
  CHECKERS[type](issues, objectNode);
}

function checkInternal(jsonStr) {
  const issues = [];
  let ast;

  try {
    ast = parse(jsonStr, {
      ranges: true
    });
    checkObject(issues, ast.body);
  } catch (e) {
    issues.push({
      message: `Invalid JSON: ${e.message}`,
      from: 0,
      to: 0,
      severity: 'error'
    });
  }

  return {
    ast,
    issues
  };
}

const getIssues = jsonStr => {
  return checkInternal(jsonStr).issues;
};
const check = jsonStr => {
  const {
    issues,
    ast
  } = checkInternal(jsonStr);
  if (issues.length || !ast) throw new HintError(issues);
  return evaluate(ast);
};

export { HintError, check, getIssues };
//# sourceMappingURL=check-geojson.esm.js.map
